{"version":3,"sources":["webpack:///./node_modules/zrender/lib/core/arrayDiff2.js","webpack:///./node_modules/zrender/lib/svg/graphic.js","webpack:///./node_modules/zrender/lib/svg/helper/Definable.js","webpack:///./node_modules/zrender/lib/svg/core.js","webpack:///./node_modules/zrender/lib/svg/svg.js","webpack:///./node_modules/zrender/lib/svg/helper/ClippathManager.js","webpack:///./node_modules/zrender/lib/svg/helper/GradientManager.js","webpack:///./node_modules/zrender/lib/svg/helper/ShadowManager.js","webpack:///./src/components/echart/echartbarzhu.vue?83ae","webpack:///src/components/echart/echartbarzhu.vue","webpack:///./src/components/echart/echartbarzhu.vue?2cd6","webpack:///./src/components/echart/echartbarzhu.vue","webpack:///./node_modules/zrender/lib/svg/Painter.js"],"names":["Diff","buildValues","diff","components","newArr","oldArr","componentPos","componentLen","length","newPos","oldPos","component","removed","indices","i","count","push","added","clonePath","path","slice","prototype","equals","a","b","this","self","newLen","oldLen","editLength","maxEditLength","bestPath","extractCommon","execEditLength","diagonalPath","basePath","addPath","removePath","undefined","canAdd","canRemove","pushComponent","ret","last","commonCount","tokenize","value","join","arrayDiff","_default","callback","module","exports","_core","__webpack_require__","createElement","PathProxy","BoundingRect","matrix","textContain","textHelper","Text","CMD","arrayJoin","Array","NONE","mathRound","Math","round","mathSin","sin","mathCos","cos","PI","PI2","degree","EPSILON","round4","val","isAroundZero","pathHasFill","style","isText","fill","textFill","pathHasStroke","stroke","textStroke","setTransform","svgEl","m","attr","call","el","key","type","setAttribute","attrXLink","setAttributeNS","bindStyle","getAttribute","fillOpacity","opacity","strokeWidth","textStrokeWidth","lineWidth","strokeScale","strokeNoScale","getLineScale","strokeOpacity","lineDash","lineDashOffset","lineCap","lineJoin","miterLimit","pathDataToString","str","data","dataLength","len","cmd","cmdStr","nData","M","L","Q","C","A","cx","cy","rx","ry","theta","dTheta","psi","clockwise","dThetaPositive","abs","isCircle","large","x0","y0","x","y","Z","R","w","h","j","svgPath","brush","__svgEl","createPathProxy","__dirtyPath","beginPath","subPixelOptimize","buildPath","shape","pathStr","indexOf","transform","text","svgTextDrawRectText","getBoundingRect","svgImage","image","HTMLImageElement","src","dw","width","dh","height","__imageSrc","svgText","tmpRect","rect","textRect","__dirty","normalizeTextStyle","textSvgEl","__textSvgEl","textPosition","distance","textDistance","align","textAlign","fontSize","font","fontStyle","fontWeight","fontFamily","DEFAULT_FONT","verticalAlign","getVerticalAlignForSvg","textVerticalAlign","textPadding","textLineHeight","lineHeight","adjustTextPositionOnRect","transformText","copy","applyTransform","pos","transformCoordToGlobal","identity","create","origin","textOrigin","rotate","textRotation","translate","textLines","split","nTextLines","textAnchor","dy","__text","__textFont","tspanList","__tspanList","tspan","innerHTML","appendChild","document","createTextNode","removeChild","drawRectText","zrUtil","Path","ZImage","ZText","_graphic","MARK_UNUSED","MARK_USED","Definable","zrId","svgRoot","tagNames","markLabel","domName","_zrId","_svgRoot","_tagNames","_markLabel","_domName","nextId","getDefs","isForceCreating","defs","getElementsByTagName","insertBefore","firstChild","contains","children","update","element","onUpdate","dom","add","addDom","removeDom","getDoms","doms","each","tagName","tags","concat","markAllUnused","that","markUsed","removeUnused","getSvgProxy","displayable","getTextSvgElement","getSvgElement","svgURI","name","createElementNS","_zrender","registerPainter","Painter","ClippathManager","inherits","updateDom","__clipPaths","textEl","parentEl","clipPaths","clipPathEl","id","clipPath","svgProxy","parent","invTransform","mul","pathEl","cloneNode","_dom","_textDom","zrLog","colorTool","GradientManager","addWithoutUpdate","svgElement","fillOrStroke","gradient","x2","y2","r","global","colors","colorStops","stop","offset","color","parse","hex","toHex","ShadowManager","hasShadow","shadowBlur","shadowOffsetX","shadowOffsetY","textShadowBlur","textShadowOffsetX","textShadowOffsetY","_shadowDom","filter","_shadowDomId","remove","domChild","offsetX","offsetY","blur","scaleX","scale","scaleY","shadowColor","textShadowColor","stdDx","stdDy","stdDeviation","ceil","render","_vm","_h","$createElement","_c","_self","_t","attrs","elId","staticRenderFns","echartbarzhuvue_type_script_lang_js_","props","String","default","Object","echarts_default","graphic","LinearGradient","xAxisDate","seriesData","title","unit","created","v1_default","computed","mounted","mytextStyle","mylineStyle","legendData","option","animation","tooltip","trigger","axisPointer","shadowStyle","extraCssText","grid","left","right","bottom","containLabel","xAxis","axisLine","splitLine","axisLabel","textStyle","interval","formatter","substr","content","yAxis","lineStyle","series","barWidth","label","show","position","chartObj","init","getElementById","renderer","setOption","echart_echartbarzhuvue_type_script_lang_js_","componentNormalizer","__webpack_exports__","util","parseInt10","parseInt","checkParentAvailable","child","parentNode","insertAfter","prevSibling","nextSibling","prepend","SVGPainter","root","storage","opts","_opts","extend","cssText","gradientManager","clipPathManager","shadowManager","viewport","_viewport","resize","_visibleList","createMethodNotSupport","method","constructor","getType","getViewportRoot","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","refresh","list","getDisplayList","_paintList","setBackgroundColor","backgroundColor","background","visibleList","listLen","newVisibleList","invisible","prevSvgElement","item","k","textSvgElement","_getDefs","display","_getSize","_width","_height","viewportStyle","getWidth","getHeight","whIdx","wh","cwh","plt","prb","parseFloat","stl","defaultView","getComputedStyle","dispose","clear","pathToDataUrl","html","outerHTML"],"mappings":"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","file":"static/js/chunk-63875a2b.ce45c008.js","sourcesContent":["// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\n\nDiff.prototype = {\n  diff: function (oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function (a, b) {\n        return a === b;\n      };\n    }\n\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function (components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function (basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function (value) {\n    return value.slice();\n  },\n  join: function (value) {\n    return value.slice();\n  }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      var indices = [];\n\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar arrayDiff = new Diff();\n\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nmodule.exports = _default;","var _core = require(\"./core\");\n\nvar createElement = _core.createElement;\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar Text = require(\"../graphic/Text\");\n\n// TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\nvar CMD = PathProxy.CMD;\nvar arrayJoin = Array.prototype.join;\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\n\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\n\nfunction pathHasFill(style, isText) {\n  var fill = isText ? style.textFill : style.fill;\n  return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style, isText) {\n  var stroke = isText ? style.textStroke : style.stroke;\n  return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\n  }\n}\n\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    // Don't set attribute for gradient, since it need new dom nodes\n    el.setAttribute(key, val);\n  }\n}\n\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction bindStyle(svgEl, style, isText, el) {\n  if (pathHasFill(style, isText)) {\n    var fill = isText ? style.textFill : style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    /**\n     * FIXME:\n     * This is a temporary fix for Chrome's clipping bug\n     * that happens when a clip-path is referring another one.\n     * This fix should be used before Chrome's bug is fixed.\n     * For an element that has clip-path, and fill is none,\n     * set it to be \"rgba(0, 0, 0, 0.002)\" will hide the element.\n     * Otherwise, it will show black fill color.\n     * 0.002 is used because this won't work for alpha values smaller\n     * than 0.002.\n     *\n     * See\n     * https://bugs.chromium.org/p/chromium/issues/detail?id=659790\n     * for more information.\n     */\n\n    if (svgEl.getAttribute('clip-path') !== 'none' && fill === NONE) {\n      fill = 'rgba(0, 0, 0, 0.002)';\n    }\n\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n\n  if (pathHasStroke(style, isText)) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\n\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\n    var lineDash = style.lineDash;\n\n    if (lineDash) {\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    } // PENDING\n\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n/***************************************************\n * PATH\n **************************************************/\n\n\nfunction pathDataToString(path) {\n  var str = [];\n  var data = path.data;\n  var dataLength = path.len();\n\n  for (var i = 0; i < dataLength;) {\n    var cmd = data[i++];\n    var cmdStr = '';\n    var nData = 0;\n\n    switch (cmd) {\n      case CMD.M:\n        cmdStr = 'M';\n        nData = 2;\n        break;\n\n      case CMD.L:\n        cmdStr = 'L';\n        nData = 2;\n        break;\n\n      case CMD.Q:\n        cmdStr = 'Q';\n        nData = 4;\n        break;\n\n      case CMD.C:\n        cmdStr = 'C';\n        nData = 6;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        var psi = data[i++];\n        var clockwise = data[i++];\n        var dThetaPositive = Math.abs(dTheta);\n        var isCircle = isAroundZero(dThetaPositive - PI2) && !isAroundZero(dThetaPositive);\n        var large = false;\n\n        if (dThetaPositive >= PI2) {\n          large = true;\n        } else if (isAroundZero(dThetaPositive)) {\n          large = false;\n        } else {\n          large = (dTheta > -PI && dTheta < 0 || dTheta > PI) === !!clockwise;\n        }\n\n        var x0 = round4(cx + rx * mathCos(theta));\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\n        // We need to shift the end point with a small value\n        // FIXME A better way to draw circle ?\n\n        if (isCircle) {\n          if (clockwise) {\n            dTheta = PI2 - 1e-4;\n          } else {\n            dTheta = -PI2 + 1e-4;\n          }\n\n          large = true;\n\n          if (i === 9) {\n            // Move to (x0, y0) only when CMD.A comes at the\n            // first position of a shape.\n            // For instance, when drawing a ring, CMD.A comes\n            // after CMD.M, so it's unnecessary to move to\n            // (x0, y0).\n            str.push('M', x0, y0);\n          }\n        }\n\n        var x = round4(cx + rx * mathCos(theta + dTheta));\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\n\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        break;\n\n      case CMD.Z:\n        cmdStr = 'Z';\n        break;\n\n      case CMD.R:\n        var x = round4(data[i++]);\n        var y = round4(data[i++]);\n        var w = round4(data[i++]);\n        var h = round4(data[i++]);\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\n        break;\n    }\n\n    cmdStr && str.push(cmdStr);\n\n    for (var j = 0; j < nData; j++) {\n      // PENDING With scale\n      str.push(round4(data[i++]));\n    }\n  }\n\n  return str.join(' ');\n}\n\nvar svgPath = {};\n\nsvgPath.brush = function (el) {\n  var style = el.style;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('path');\n    el.__svgEl = svgEl;\n  }\n\n  if (!el.path) {\n    el.createPathProxy();\n  }\n\n  var path = el.path;\n\n  if (el.__dirtyPath) {\n    path.beginPath();\n    path.subPixelOptimize = false;\n    el.buildPath(path, el.shape);\n    el.__dirtyPath = false;\n    var pathStr = pathDataToString(path);\n\n    if (pathStr.indexOf('NaN') < 0) {\n      // Ignore illegal path, which may happen such in out-of-range\n      // data in Calendar series.\n      attr(svgEl, 'd', pathStr);\n    }\n  }\n\n  bindStyle(svgEl, style, false, el);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  }\n};\n/***************************************************\n * IMAGE\n **************************************************/\n\n\nvar svgImage = {};\n\nsvgImage.brush = function (el) {\n  var style = el.style;\n  var image = style.image;\n\n  if (image instanceof HTMLImageElement) {\n    var src = image.src;\n    image = src;\n  }\n\n  if (!image) {\n    return;\n  }\n\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('image');\n    el.__svgEl = svgEl;\n  }\n\n  if (image !== el.__imageSrc) {\n    attrXLink(svgEl, 'href', image); // Caching image src\n\n    el.__imageSrc = image;\n  }\n\n  attr(svgEl, 'width', dw);\n  attr(svgEl, 'height', dh);\n  attr(svgEl, 'x', x);\n  attr(svgEl, 'y', y);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  }\n};\n/***************************************************\n * TEXT\n **************************************************/\n\n\nvar svgText = {};\nvar tmpRect = new BoundingRect();\n\nvar svgTextDrawRectText = function (el, rect, textRect) {\n  var style = el.style;\n  el.__dirty && textHelper.normalizeTextStyle(style, true);\n  var text = style.text; // Convert to string\n\n  if (text == null) {\n    // Draw no text only when text is set to null, but not ''\n    return;\n  } else {\n    text += '';\n  }\n\n  var textSvgEl = el.__textSvgEl;\n\n  if (!textSvgEl) {\n    textSvgEl = createElement('text');\n    el.__textSvgEl = textSvgEl;\n  }\n\n  var x;\n  var y;\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var align = style.textAlign || 'left';\n\n  if (typeof style.fontSize === 'number') {\n    style.fontSize += 'px';\n  }\n\n  var font = style.font || [style.fontStyle || '', style.fontWeight || '', style.fontSize || '', style.fontFamily || ''].join(' ') || textContain.DEFAULT_FONT;\n  var verticalAlign = getVerticalAlignForSvg(style.textVerticalAlign);\n  textRect = textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight);\n  var lineHeight = textRect.lineHeight; // Text position represented by coord\n\n  if (textPosition instanceof Array) {\n    x = rect.x + textPosition[0];\n    y = rect.y + textPosition[1];\n  } else {\n    var newPos = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n    x = newPos.x;\n    y = newPos.y;\n    verticalAlign = getVerticalAlignForSvg(newPos.textVerticalAlign);\n    align = newPos.textAlign;\n  }\n\n  attr(textSvgEl, 'alignment-baseline', verticalAlign);\n\n  if (font) {\n    textSvgEl.style.font = font;\n  }\n\n  var textPadding = style.textPadding; // Make baseline top\n\n  attr(textSvgEl, 'x', x);\n  attr(textSvgEl, 'y', y);\n  bindStyle(textSvgEl, style, true, el);\n\n  if (el instanceof Text || el.style.transformText) {\n    // Transform text with element\n    setTransform(textSvgEl, el.transform);\n  } else {\n    if (el.transform) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(el.transform);\n      rect = tmpRect;\n    } else {\n      var pos = el.transformCoordToGlobal(rect.x, rect.y);\n      rect.x = pos[0];\n      rect.y = pos[1];\n      el.transform = matrix.identity(matrix.create());\n    } // Text rotation, but no element transform\n\n\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = textRect.width / 2 + x;\n      y = textRect.height / 2 + y;\n    } else if (origin) {\n      x = origin[0] + x;\n      y = origin[1] + y;\n    }\n\n    var rotate = -style.textRotation || 0;\n    var transform = matrix.create(); // Apply textRotate to element matrix\n\n    matrix.rotate(transform, transform, rotate);\n    var pos = [el.transform[4], el.transform[5]];\n    matrix.translate(transform, transform, pos);\n    setTransform(textSvgEl, transform);\n  }\n\n  var textLines = text.split('\\n');\n  var nTextLines = textLines.length;\n  var textAnchor = align; // PENDING\n\n  if (textAnchor === 'left') {\n    textAnchor = 'start';\n    textPadding && (x += textPadding[3]);\n  } else if (textAnchor === 'right') {\n    textAnchor = 'end';\n    textPadding && (x -= textPadding[1]);\n  } else if (textAnchor === 'center') {\n    textAnchor = 'middle';\n    textPadding && (x += (textPadding[3] - textPadding[1]) / 2);\n  }\n\n  var dy = 0;\n\n  if (verticalAlign === 'after-edge') {\n    dy = -textRect.height + lineHeight;\n    textPadding && (dy -= textPadding[2]);\n  } else if (verticalAlign === 'middle') {\n    dy = (-textRect.height + lineHeight) / 2;\n    textPadding && (y += (textPadding[0] - textPadding[2]) / 2);\n  } else {\n    textPadding && (dy += textPadding[0]);\n  } // Font may affect position of each tspan elements\n\n\n  if (el.__text !== text || el.__textFont !== font) {\n    var tspanList = el.__tspanList || [];\n    el.__tspanList = tspanList;\n\n    for (var i = 0; i < nTextLines; i++) {\n      // Using cached tspan elements\n      var tspan = tspanList[i];\n\n      if (!tspan) {\n        tspan = tspanList[i] = createElement('tspan');\n        textSvgEl.appendChild(tspan);\n        attr(tspan, 'alignment-baseline', verticalAlign);\n        attr(tspan, 'text-anchor', textAnchor);\n      } else {\n        tspan.innerHTML = '';\n      }\n\n      attr(tspan, 'x', x);\n      attr(tspan, 'y', y + i * lineHeight + dy);\n      tspan.appendChild(document.createTextNode(textLines[i]));\n    } // Remove unsed tspan elements\n\n\n    for (; i < tspanList.length; i++) {\n      textSvgEl.removeChild(tspanList[i]);\n    }\n\n    tspanList.length = nTextLines;\n    el.__text = text;\n    el.__textFont = font;\n  } else if (el.__tspanList.length) {\n    // Update span x and y\n    var len = el.__tspanList.length;\n\n    for (var i = 0; i < len; ++i) {\n      var tspan = el.__tspanList[i];\n\n      if (tspan) {\n        attr(tspan, 'x', x);\n        attr(tspan, 'y', y + i * lineHeight + dy);\n      }\n    }\n  }\n};\n\nfunction getVerticalAlignForSvg(verticalAlign) {\n  if (verticalAlign === 'middle') {\n    return 'middle';\n  } else if (verticalAlign === 'bottom') {\n    return 'after-edge';\n  } else {\n    return 'hanging';\n  }\n}\n\nsvgText.drawRectText = svgTextDrawRectText;\n\nsvgText.brush = function (el) {\n  var style = el.style;\n\n  if (style.text != null) {\n    // 强制设置 textPosition\n    style.textPosition = [0, 0];\n    svgTextDrawRectText(el, {\n      x: style.x || 0,\n      y: style.y || 0,\n      width: 0,\n      height: 0\n    }, el.getBoundingRect());\n  }\n};\n\nexports.path = svgPath;\nexports.image = svgImage;\nexports.text = svgText;","var _core = require(\"../core\");\n\nvar createElement = _core.createElement;\n\nvar zrUtil = require(\"../../core/util\");\n\nvar Path = require(\"../../graphic/Path\");\n\nvar ZImage = require(\"../../graphic/Image\");\n\nvar ZText = require(\"../../graphic/Text\");\n\nvar _graphic = require(\"../graphic\");\n\nvar svgPath = _graphic.path;\nvar svgImage = _graphic.image;\nvar svgText = _graphic.text;\n\n/**\n * @file Manages elements that can be defined in <defs> in SVG,\n *       e.g., gradients, clip path, etc.\n * @author Zhang Wenli\n */\nvar MARK_UNUSED = '0';\nvar MARK_USED = '1';\n/**\n * Manages elements that can be defined in <defs> in SVG,\n * e.g., gradients, clip path, etc.\n *\n * @class\n * @param {number}          zrId      zrender instance id\n * @param {SVGElement}      svgRoot   root of SVG document\n * @param {string|string[]} tagNames  possible tag names\n * @param {string}          markLabel label name to make if the element\n *                                    is used\n */\n\nfunction Definable(zrId, svgRoot, tagNames, markLabel, domName) {\n  this._zrId = zrId;\n  this._svgRoot = svgRoot;\n  this._tagNames = typeof tagNames === 'string' ? [tagNames] : tagNames;\n  this._markLabel = markLabel;\n  this._domName = domName || '_dom';\n  this.nextId = 0;\n}\n\nDefinable.prototype.createElement = createElement;\n/**\n * Get the <defs> tag for svgRoot; optionally creates one if not exists.\n *\n * @param {boolean} isForceCreating if need to create when not exists\n * @return {SVGDefsElement} SVG <defs> element, null if it doesn't\n * exist and isForceCreating is false\n */\n\nDefinable.prototype.getDefs = function (isForceCreating) {\n  var svgRoot = this._svgRoot;\n\n  var defs = this._svgRoot.getElementsByTagName('defs');\n\n  if (defs.length === 0) {\n    // Not exist\n    if (isForceCreating) {\n      defs = svgRoot.insertBefore(this.createElement('defs'), // Create new tag\n      svgRoot.firstChild // Insert in the front of svg\n      );\n\n      if (!defs.contains) {\n        // IE doesn't support contains method\n        defs.contains = function (el) {\n          var children = defs.children;\n\n          if (!children) {\n            return false;\n          }\n\n          for (var i = children.length - 1; i >= 0; --i) {\n            if (children[i] === el) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n      }\n\n      return defs;\n    } else {\n      return null;\n    }\n  } else {\n    return defs[0];\n  }\n};\n/**\n * Update DOM element if necessary.\n *\n * @param {Object|string} element style element. e.g., for gradient,\n *                                it may be '#ccc' or {type: 'linear', ...}\n * @param {Function|undefined} onUpdate update callback\n */\n\n\nDefinable.prototype.update = function (element, onUpdate) {\n  if (!element) {\n    return;\n  }\n\n  var defs = this.getDefs(false);\n\n  if (element[this._domName] && defs.contains(element[this._domName])) {\n    // Update DOM\n    if (typeof onUpdate === 'function') {\n      onUpdate(element);\n    }\n  } else {\n    // No previous dom, create new\n    var dom = this.add(element);\n\n    if (dom) {\n      element[this._domName] = dom;\n    }\n  }\n};\n/**\n * Add gradient dom to defs\n *\n * @param {SVGElement} dom DOM to be added to <defs>\n */\n\n\nDefinable.prototype.addDom = function (dom) {\n  var defs = this.getDefs(true);\n  defs.appendChild(dom);\n};\n/**\n * Remove DOM of a given element.\n *\n * @param {SVGElement} element element to remove dom\n */\n\n\nDefinable.prototype.removeDom = function (element) {\n  var defs = this.getDefs(false);\n\n  if (defs && element[this._domName]) {\n    defs.removeChild(element[this._domName]);\n    element[this._domName] = null;\n  }\n};\n/**\n * Get DOMs of this element.\n *\n * @return {HTMLDomElement} doms of this defineable elements in <defs>\n */\n\n\nDefinable.prototype.getDoms = function () {\n  var defs = this.getDefs(false);\n\n  if (!defs) {\n    // No dom when defs is not defined\n    return [];\n  }\n\n  var doms = [];\n  zrUtil.each(this._tagNames, function (tagName) {\n    var tags = defs.getElementsByTagName(tagName); // Note that tags is HTMLCollection, which is array-like\n    // rather than real array.\n    // So `doms.concat(tags)` add tags as one object.\n\n    doms = doms.concat([].slice.call(tags));\n  });\n  return doms;\n};\n/**\n * Mark DOMs to be unused before painting, and clear unused ones at the end\n * of the painting.\n */\n\n\nDefinable.prototype.markAllUnused = function () {\n  var doms = this.getDoms();\n  var that = this;\n  zrUtil.each(doms, function (dom) {\n    dom[that._markLabel] = MARK_UNUSED;\n  });\n};\n/**\n * Mark a single DOM to be used.\n *\n * @param {SVGElement} dom DOM to mark\n */\n\n\nDefinable.prototype.markUsed = function (dom) {\n  if (dom) {\n    dom[this._markLabel] = MARK_USED;\n  }\n};\n/**\n * Remove unused DOMs defined in <defs>\n */\n\n\nDefinable.prototype.removeUnused = function () {\n  var defs = this.getDefs(false);\n\n  if (!defs) {\n    // Nothing to remove\n    return;\n  }\n\n  var doms = this.getDoms();\n  var that = this;\n  zrUtil.each(doms, function (dom) {\n    if (dom[that._markLabel] !== MARK_USED) {\n      // Remove gradient\n      defs.removeChild(dom);\n    }\n  });\n};\n/**\n * Get SVG proxy.\n *\n * @param {Displayable} displayable displayable element\n * @return {Path|Image|Text} svg proxy of given element\n */\n\n\nDefinable.prototype.getSvgProxy = function (displayable) {\n  if (displayable instanceof Path) {\n    return svgPath;\n  } else if (displayable instanceof ZImage) {\n    return svgImage;\n  } else if (displayable instanceof ZText) {\n    return svgText;\n  } else {\n    return svgPath;\n  }\n};\n/**\n * Get text SVG element.\n *\n * @param {Displayable} displayable displayable element\n * @return {SVGElement} SVG element of text\n */\n\n\nDefinable.prototype.getTextSvgElement = function (displayable) {\n  return displayable.__textSvgEl;\n};\n/**\n * Get SVG element.\n *\n * @param {Displayable} displayable displayable element\n * @return {SVGElement} SVG element\n */\n\n\nDefinable.prototype.getSvgElement = function (displayable) {\n  return displayable.__svgEl;\n};\n\nvar _default = Definable;\nmodule.exports = _default;","var svgURI = 'http://www.w3.org/2000/svg';\n\nfunction createElement(name) {\n  return document.createElementNS(svgURI, name);\n}\n\nexports.createElement = createElement;","require(\"./graphic\");\n\nvar _zrender = require(\"../zrender\");\n\nvar registerPainter = _zrender.registerPainter;\n\nvar Painter = require(\"./Painter\");\n\nregisterPainter('svg', Painter);","var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar matrix = require(\"../../core/matrix\");\n\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ClippathManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr' + this._zrId + '-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    clipPathEl.innerHTML = '';\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this;\n\n  if (displayable.__clipPaths && displayable.__clipPaths.length > 0) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;","var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar zrLog = require(\"../../core/log\");\n\nvar colorTool = require(\"../../tool/color\");\n\n/**\n * @file Manages SVG gradient elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG gradient elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction GradientManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, ['linearGradient', 'radialGradient'], '__gradient_in_use__');\n}\n\nzrUtil.inherits(GradientManager, Definable);\n/**\n * Create new gradient DOM for fill or stroke if not exist,\n * but will not update gradient if exists.\n *\n * @param {SvgElement}  svgElement   SVG element to paint\n * @param {Displayable} displayable  zrender displayable element\n */\n\nGradientManager.prototype.addWithoutUpdate = function (svgElement, displayable) {\n  if (displayable && displayable.style) {\n    var that = this;\n    zrUtil.each(['fill', 'stroke'], function (fillOrStroke) {\n      if (displayable.style[fillOrStroke] && (displayable.style[fillOrStroke].type === 'linear' || displayable.style[fillOrStroke].type === 'radial')) {\n        var gradient = displayable.style[fillOrStroke];\n        var defs = that.getDefs(true); // Create dom in <defs> if not exists\n\n        var dom;\n\n        if (gradient._dom) {\n          // Gradient exists\n          dom = gradient._dom;\n\n          if (!defs.contains(gradient._dom)) {\n            // _dom is no longer in defs, recreate\n            that.addDom(dom);\n          }\n        } else {\n          // New dom\n          dom = that.add(gradient);\n        }\n\n        that.markUsed(displayable);\n        var id = dom.getAttribute('id');\n        svgElement.setAttribute(fillOrStroke, 'url(#' + id + ')');\n      }\n    });\n  }\n};\n/**\n * Add a new gradient tag in <defs>\n *\n * @param   {Gradient} gradient zr gradient instance\n * @return {SVGLinearGradientElement | SVGRadialGradientElement}\n *                            created DOM\n */\n\n\nGradientManager.prototype.add = function (gradient) {\n  var dom;\n\n  if (gradient.type === 'linear') {\n    dom = this.createElement('linearGradient');\n  } else if (gradient.type === 'radial') {\n    dom = this.createElement('radialGradient');\n  } else {\n    zrLog('Illegal gradient type.');\n    return null;\n  } // Set dom id with gradient id, since each gradient instance\n  // will have no more than one dom element.\n  // id may exists before for those dirty elements, in which case\n  // id should remain the same, and other attributes should be\n  // updated.\n\n\n  gradient.id = gradient.id || this.nextId++;\n  dom.setAttribute('id', 'zr' + this._zrId + '-gradient-' + gradient.id);\n  this.updateDom(gradient, dom);\n  this.addDom(dom);\n  return dom;\n};\n/**\n * Update gradient.\n *\n * @param {Gradient} gradient zr gradient instance\n */\n\n\nGradientManager.prototype.update = function (gradient) {\n  var that = this;\n  Definable.prototype.update.call(this, gradient, function () {\n    var type = gradient.type;\n    var tagName = gradient._dom.tagName;\n\n    if (type === 'linear' && tagName === 'linearGradient' || type === 'radial' && tagName === 'radialGradient') {\n      // Gradient type is not changed, update gradient\n      that.updateDom(gradient, gradient._dom);\n    } else {\n      // Remove and re-create if type is changed\n      that.removeDom(gradient);\n      that.add(gradient);\n    }\n  });\n};\n/**\n * Update gradient dom\n *\n * @param {Gradient} gradient zr gradient instance\n * @param {SVGLinearGradientElement | SVGRadialGradientElement} dom\n *                            DOM to update\n */\n\n\nGradientManager.prototype.updateDom = function (gradient, dom) {\n  if (gradient.type === 'linear') {\n    dom.setAttribute('x1', gradient.x);\n    dom.setAttribute('y1', gradient.y);\n    dom.setAttribute('x2', gradient.x2);\n    dom.setAttribute('y2', gradient.y2);\n  } else if (gradient.type === 'radial') {\n    dom.setAttribute('cx', gradient.x);\n    dom.setAttribute('cy', gradient.y);\n    dom.setAttribute('r', gradient.r);\n  } else {\n    zrLog('Illegal gradient type.');\n    return;\n  }\n\n  if (gradient.global) {\n    // x1, x2, y1, y2 in range of 0 to canvas width or height\n    dom.setAttribute('gradientUnits', 'userSpaceOnUse');\n  } else {\n    // x1, x2, y1, y2 in range of 0 to 1\n    dom.setAttribute('gradientUnits', 'objectBoundingBox');\n  } // Remove color stops if exists\n\n\n  dom.innerHTML = ''; // Add color stops\n\n  var colors = gradient.colorStops;\n\n  for (var i = 0, len = colors.length; i < len; ++i) {\n    var stop = this.createElement('stop');\n    stop.setAttribute('offset', colors[i].offset * 100 + '%');\n    var color = colors[i].color;\n\n    if (color.indexOf('rgba' > -1)) {\n      // Fix Safari bug that stop-color not recognizing alpha #9014\n      var opacity = colorTool.parse(color)[3];\n      var hex = colorTool.toHex(color); // stop-color cannot be color, since:\n      // The opacity value used for the gradient calculation is the\n      // *product* of the value of stop-opacity and the opacity of the\n      // value of stop-color.\n      // See https://www.w3.org/TR/SVG2/pservers.html#StopOpacityProperty\n\n      stop.setAttribute('stop-color', '#' + hex);\n      stop.setAttribute('stop-opacity', opacity);\n    } else {\n      stop.setAttribute('stop-color', colors[i].color);\n    }\n\n    dom.appendChild(stop);\n  } // Store dom element in gradient, to avoid creating multiple\n  // dom instances for the same gradient element\n\n\n  gradient._dom = dom;\n};\n/**\n * Mark a single gradient to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nGradientManager.prototype.markUsed = function (displayable) {\n  if (displayable.style) {\n    var gradient = displayable.style.fill;\n\n    if (gradient && gradient._dom) {\n      Definable.prototype.markUsed.call(this, gradient._dom);\n    }\n\n    gradient = displayable.style.stroke;\n\n    if (gradient && gradient._dom) {\n      Definable.prototype.markUsed.call(this, gradient._dom);\n    }\n  }\n};\n\nvar _default = GradientManager;\nmodule.exports = _default;","var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\n/**\n * @file Manages SVG shadow elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG shadow elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ShadowManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, ['filter'], '__filter_in_use__', '_shadowDom');\n}\n\nzrUtil.inherits(ShadowManager, Definable);\n/**\n * Create new shadow DOM for fill or stroke if not exist,\n * but will not update shadow if exists.\n *\n * @param {SvgElement}  svgElement   SVG element to paint\n * @param {Displayable} displayable  zrender displayable element\n */\n\nShadowManager.prototype.addWithoutUpdate = function (svgElement, displayable) {\n  if (displayable && hasShadow(displayable.style)) {\n    var style = displayable.style; // Create dom in <defs> if not exists\n\n    var dom;\n\n    if (style._shadowDom) {\n      // Gradient exists\n      dom = style._shadowDom;\n      var defs = this.getDefs(true);\n\n      if (!defs.contains(style._shadowDom)) {\n        // _shadowDom is no longer in defs, recreate\n        this.addDom(dom);\n      }\n    } else {\n      // New dom\n      dom = this.add(displayable);\n    }\n\n    this.markUsed(displayable);\n    var id = dom.getAttribute('id');\n    svgElement.style.filter = 'url(#' + id + ')';\n  }\n};\n/**\n * Add a new shadow tag in <defs>\n *\n * @param {Displayable} displayable  zrender displayable element\n * @return {SVGFilterElement} created DOM\n */\n\n\nShadowManager.prototype.add = function (displayable) {\n  var dom = this.createElement('filter');\n  var style = displayable.style; // Set dom id with shadow id, since each shadow instance\n  // will have no more than one dom element.\n  // id may exists before for those dirty elements, in which case\n  // id should remain the same, and other attributes should be\n  // updated.\n\n  style._shadowDomId = style._shadowDomId || this.nextId++;\n  dom.setAttribute('id', 'zr' + this._zrId + '-shadow-' + style._shadowDomId);\n  this.updateDom(displayable, dom);\n  this.addDom(dom);\n  return dom;\n};\n/**\n * Update shadow.\n *\n * @param {Displayable} displayable  zrender displayable element\n */\n\n\nShadowManager.prototype.update = function (svgElement, displayable) {\n  var style = displayable.style;\n\n  if (hasShadow(style)) {\n    var that = this;\n    Definable.prototype.update.call(this, displayable, function (style) {\n      that.updateDom(displayable, style._shadowDom);\n    });\n  } else {\n    // Remove shadow\n    this.remove(svgElement, style);\n  }\n};\n/**\n * Remove DOM and clear parent filter\n */\n\n\nShadowManager.prototype.remove = function (svgElement, style) {\n  if (style._shadowDomId != null) {\n    this.removeDom(style);\n    svgElement.style.filter = '';\n  }\n};\n/**\n * Update shadow dom\n *\n * @param {Displayable} displayable  zrender displayable element\n * @param {SVGFilterElement} dom DOM to update\n */\n\n\nShadowManager.prototype.updateDom = function (displayable, dom) {\n  var domChild = dom.getElementsByTagName('feDropShadow');\n\n  if (domChild.length === 0) {\n    domChild = this.createElement('feDropShadow');\n  } else {\n    domChild = domChild[0];\n  }\n\n  var style = displayable.style;\n  var scaleX = displayable.scale ? displayable.scale[0] || 1 : 1;\n  var scaleY = displayable.scale ? displayable.scale[1] || 1 : 1; // TODO: textBoxShadowBlur is not supported yet\n\n  var offsetX, offsetY, blur, color;\n\n  if (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY) {\n    offsetX = style.shadowOffsetX || 0;\n    offsetY = style.shadowOffsetY || 0;\n    blur = style.shadowBlur;\n    color = style.shadowColor;\n  } else if (style.textShadowBlur) {\n    offsetX = style.textShadowOffsetX || 0;\n    offsetY = style.textShadowOffsetY || 0;\n    blur = style.textShadowBlur;\n    color = style.textShadowColor;\n  } else {\n    // Remove shadow\n    this.removeDom(dom, style);\n    return;\n  }\n\n  domChild.setAttribute('dx', offsetX / scaleX);\n  domChild.setAttribute('dy', offsetY / scaleY);\n  domChild.setAttribute('flood-color', color); // Divide by two here so that it looks the same as in canvas\n  // See: https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-shadowblur\n\n  var stdDx = blur / 2 / scaleX;\n  var stdDy = blur / 2 / scaleY;\n  var stdDeviation = stdDx + ' ' + stdDy;\n  domChild.setAttribute('stdDeviation', stdDeviation); // Fix filter clipping problem\n\n  dom.setAttribute('x', '-100%');\n  dom.setAttribute('y', '-100%');\n  dom.setAttribute('width', Math.ceil(blur / 2 * 200) + '%');\n  dom.setAttribute('height', Math.ceil(blur / 2 * 200) + '%');\n  dom.appendChild(domChild); // Store dom element in shadow, to avoid creating multiple\n  // dom instances for the same shadow element\n\n  style._shadowDom = dom;\n};\n/**\n * Mark a single shadow to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nShadowManager.prototype.markUsed = function (displayable) {\n  var style = displayable.style;\n\n  if (style && style._shadowDom) {\n    Definable.prototype.markUsed.call(this, style._shadowDom);\n  }\n};\n\nfunction hasShadow(style) {\n  // TODO: textBoxShadowBlur is not supported yet\n  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY || style.textShadowBlur || style.textShadowOffsetX || style.textShadowOffsetY);\n}\n\nvar _default = ShadowManager;\nmodule.exports = _default;","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_vm._t(\"before\"),_c('div',{style:(_vm.style),attrs:{\"id\":_vm.elId}}),_vm._t(\"after\")],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n  <div>\r\n    <slot name=\"before\"></slot>\r\n    <div :id=\"elId\"\r\n      :style=\"style\"></div>\r\n    <slot name=\"after\"></slot>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n// 引入基本模板\r\nimport echarts from 'echarts/lib/echarts'\r\nimport 'echarts/lib/chart/bar'\r\n// 引入提示框组件、标题组件、工具箱组件。\r\nimport 'echarts/lib/component/tooltip'\r\nimport 'echarts/lib/component/title'\r\nimport 'echarts/lib/component/legend'\r\nimport 'echarts/lib/component/toolbox'\r\nimport 'zrender/lib/svg/svg' //可使用svg渲染\r\n\r\n//引入uuid文件\r\nimport uuidv1 from 'uuid/v1'\r\nexport default {\r\n  name: 'chart-bar',\r\n  props: {\r\n    width: { type: String, default: '100%' },\r\n    height: { type: String, default: '300px' },\r\n    color: {\r\n      type: [String, Object],\r\n      default() {\r\n        return new echarts.graphic.LinearGradient(0, 0, 0, 1, [\r\n          { offset: 0, color: '#01edc3' }, // 0% 处的颜色\r\n          { offset: 1, color: '#07caa6' } // 100% 处的颜色\r\n        ])\r\n      }\r\n    },\r\n    xAxisDate: {\r\n      type: Array,\r\n      default() {\r\n        return []\r\n      }\r\n    },\r\n    seriesData: {\r\n      type: Array,\r\n      default() {\r\n        return []\r\n      }\r\n    },\r\n    title: {\r\n      type: String,\r\n      default: ''\r\n    },\r\n    unit: {\r\n      type: String,\r\n      default: ''\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      elId: ''\r\n    }\r\n  },\r\n  created() {\r\n    this.elId = uuidv1() //获取随机id\r\n  },\r\n  computed: {\r\n    style() {\r\n      return {\r\n        height: this.height,\r\n        width: this.width\r\n      }\r\n    }\r\n  },\r\n\r\n  mounted() {\r\n    const mytextStyle = {\r\n      color: '#466791', //文字颜色\r\n      fontStyle: 'normal', //italic斜体  oblique倾斜\r\n      fontWeight: 'normal', //文字粗细bold   bolder   lighter  100 | 200 | 300 | 400...\r\n      fontFamily: 'MicrosoftYaHei', //字体系列\r\n      fontSize: 14 //字体大小\r\n    }\r\n    const mylineStyle = {\r\n      color: '#000', //颜色，'rgb(128, 128, 128)'，'rgba(128, 128, 128, 0.5)'，支持线性渐变，径向渐变，纹理填充\r\n      shadowColor: 'red', //阴影颜色\r\n      type: 'dotted', //坐标轴线线的类型，solid，dashed，dotted\r\n      width: 2, //坐标轴线线宽\r\n      opacity: 0.06 //图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形\r\n    }\r\n    const legendData = []\r\n    legendData.push(this.title)\r\n    const option = {\r\n      animation: false,\r\n      color: this.color,\r\n      tooltip: {\r\n        trigger: 'item', // axis\r\n        axisPointer: {\r\n          shadowStyle: {\r\n            color: 'rgba(98, 167, 255, 0.3)'\r\n          }\r\n        },\r\n        extraCssText: 'max-width:320px;white-space:pre-wrap'\r\n      },\r\n      grid: {\r\n        left: '3%',\r\n        right: '4%',\r\n        bottom: '3%',\r\n        containLabel: true\r\n      },\r\n      xAxis: [\r\n        {\r\n          type: 'category',\r\n          data: this.xAxisDate,\r\n          axisLine: false,\r\n          splitLine: false,\r\n          axisLabel: {\r\n            textStyle: mytextStyle,\r\n            interval: 0,\r\n            formatter(value) {\r\n              let val = []\r\n              for (let i = 0; i < value.length; i += 5) {\r\n                val.push(value.substr(i, 5))\r\n              }\r\n              let content = val.join('\\n')\r\n              return value.length >= 27 ? `${content.slice(0, 27)}...` : content\r\n            }\r\n          }\r\n        }\r\n      ],\r\n      yAxis: [\r\n        {\r\n          type: 'value',\r\n          axisLine: false,\r\n          splitLine: {\r\n            //坐标轴在 grid 区域中的分隔线。\r\n            lineStyle: mylineStyle\r\n          },\r\n          axisLabel: {\r\n            textStyle: mytextStyle,\r\n            formatter: `{value} ${this.unit}`\r\n          }\r\n        }\r\n      ],\r\n      series: [\r\n        {\r\n          name: this.title,\r\n          type: 'bar',\r\n          barWidth: '60%',\r\n          label: {\r\n            show: true, //开启显示\r\n            position: 'top', //在上方显示\r\n            formatter: `{c} ${this.unit}`,\r\n            fontSize: 14,\r\n            color: '#ccc'\r\n          },\r\n\r\n          data: this.seriesData\r\n        }\r\n      ]\r\n    }\r\n    const chartObj = echarts.init(document.getElementById(this.elId), null, { renderer: 'svg' })\r\n    chartObj.setOption(option)\r\n  }\r\n}\r\n</script>\r\n\r\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./echartbarzhu.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./echartbarzhu.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./echartbarzhu.vue?vue&type=template&id=734ed148&\"\nimport script from \"./echartbarzhu.vue?vue&type=script&lang=js&\"\nexport * from \"./echartbarzhu.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var _core = require(\"./core\");\n\nvar createElement = _core.createElement;\n\nvar util = require(\"../core/util\");\n\nvar zrLog = require(\"../core/log\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar ZText = require(\"../graphic/Text\");\n\nvar arrayDiff = require(\"../core/arrayDiff2\");\n\nvar GradientManager = require(\"./helper/GradientManager\");\n\nvar ClippathManager = require(\"./helper/ClippathManager\");\n\nvar ShadowManager = require(\"./helper/ShadowManager\");\n\nvar _graphic = require(\"./graphic\");\n\nvar svgPath = _graphic.path;\nvar svgImage = _graphic.image;\nvar svgText = _graphic.text;\n\n/**\n * SVG Painter\n * @module zrender/svg/Painter\n */\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction getSvgProxy(el) {\n  if (el instanceof Path) {\n    return svgPath;\n  } else if (el instanceof ZImage) {\n    return svgImage;\n  } else if (el instanceof ZText) {\n    return svgText;\n  } else {\n    return svgPath;\n  }\n}\n\nfunction checkParentAvailable(parent, child) {\n  return child && parent && child.parentNode !== parent;\n}\n\nfunction insertAfter(parent, child, prevSibling) {\n  if (checkParentAvailable(parent, child) && prevSibling) {\n    var nextSibling = prevSibling.nextSibling;\n    nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);\n  }\n}\n\nfunction prepend(parent, child) {\n  if (checkParentAvailable(parent, child)) {\n    var firstChild = parent.firstChild;\n    firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);\n  }\n}\n\nfunction append(parent, child) {\n  if (checkParentAvailable(parent, child)) {\n    parent.appendChild(child);\n  }\n}\n\nfunction remove(parent, child) {\n  if (child && parent && child.parentNode === parent) {\n    parent.removeChild(child);\n  }\n}\n\nfunction getTextSvgElement(displayable) {\n  return displayable.__textSvgEl;\n}\n\nfunction getSvgElement(displayable) {\n  return displayable.__svgEl;\n}\n/**\n * @alias module:zrender/svg/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar SVGPainter = function (root, storage, opts, zrId) {\n  this.root = root;\n  this.storage = storage;\n  this._opts = opts = util.extend({}, opts || {});\n  var svgRoot = createElement('svg');\n  svgRoot.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgRoot.setAttribute('version', '1.1');\n  svgRoot.setAttribute('baseProfile', 'full');\n  svgRoot.style.cssText = 'user-select:none;position:absolute;left:0;top:0;';\n  this.gradientManager = new GradientManager(zrId, svgRoot);\n  this.clipPathManager = new ClippathManager(zrId, svgRoot);\n  this.shadowManager = new ShadowManager(zrId, svgRoot);\n  var viewport = document.createElement('div');\n  viewport.style.cssText = 'overflow:hidden;position:relative';\n  this._svgRoot = svgRoot;\n  this._viewport = viewport;\n  root.appendChild(viewport);\n  viewport.appendChild(svgRoot);\n  this.resize(opts.width, opts.height);\n  this._visibleList = [];\n};\n\nSVGPainter.prototype = {\n  constructor: SVGPainter,\n  getType: function () {\n    return 'svg';\n  },\n  getViewportRoot: function () {\n    return this._viewport;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n  refresh: function () {\n    var list = this.storage.getDisplayList(true);\n\n    this._paintList(list);\n  },\n  setBackgroundColor: function (backgroundColor) {\n    // TODO gradient\n    this._viewport.style.background = backgroundColor;\n  },\n  _paintList: function (list) {\n    this.gradientManager.markAllUnused();\n    this.clipPathManager.markAllUnused();\n    this.shadowManager.markAllUnused();\n    var svgRoot = this._svgRoot;\n    var visibleList = this._visibleList;\n    var listLen = list.length;\n    var newVisibleList = [];\n    var i;\n\n    for (i = 0; i < listLen; i++) {\n      var displayable = list[i];\n      var svgProxy = getSvgProxy(displayable);\n      var svgElement = getSvgElement(displayable) || getTextSvgElement(displayable);\n\n      if (!displayable.invisible) {\n        if (displayable.__dirty) {\n          svgProxy && svgProxy.brush(displayable); // Update clipPath\n\n          this.clipPathManager.update(displayable); // Update gradient and shadow\n\n          if (displayable.style) {\n            this.gradientManager.update(displayable.style.fill);\n            this.gradientManager.update(displayable.style.stroke);\n            this.shadowManager.update(svgElement, displayable);\n          }\n\n          displayable.__dirty = false;\n        }\n\n        newVisibleList.push(displayable);\n      }\n    }\n\n    var diff = arrayDiff(visibleList, newVisibleList);\n    var prevSvgElement; // First do remove, in case element moved to the head and do remove\n    // after add\n\n    for (i = 0; i < diff.length; i++) {\n      var item = diff[i];\n\n      if (item.removed) {\n        for (var k = 0; k < item.count; k++) {\n          var displayable = visibleList[item.indices[k]];\n          var svgElement = getSvgElement(displayable);\n          var textSvgElement = getTextSvgElement(displayable);\n          remove(svgRoot, svgElement);\n          remove(svgRoot, textSvgElement);\n        }\n      }\n    }\n\n    for (i = 0; i < diff.length; i++) {\n      var item = diff[i];\n\n      if (item.added) {\n        for (var k = 0; k < item.count; k++) {\n          var displayable = newVisibleList[item.indices[k]];\n          var svgElement = getSvgElement(displayable);\n          var textSvgElement = getTextSvgElement(displayable);\n          prevSvgElement ? insertAfter(svgRoot, svgElement, prevSvgElement) : prepend(svgRoot, svgElement);\n\n          if (svgElement) {\n            insertAfter(svgRoot, textSvgElement, svgElement);\n          } else if (prevSvgElement) {\n            insertAfter(svgRoot, textSvgElement, prevSvgElement);\n          } else {\n            prepend(svgRoot, textSvgElement);\n          } // Insert text\n\n\n          insertAfter(svgRoot, textSvgElement, svgElement);\n          prevSvgElement = textSvgElement || svgElement || prevSvgElement;\n          this.gradientManager.addWithoutUpdate(svgElement, displayable);\n          this.shadowManager.addWithoutUpdate(prevSvgElement, displayable);\n          this.clipPathManager.markUsed(displayable);\n        }\n      } else if (!item.removed) {\n        for (var k = 0; k < item.count; k++) {\n          var displayable = newVisibleList[item.indices[k]];\n          prevSvgElement = svgElement = getTextSvgElement(displayable) || getSvgElement(displayable) || prevSvgElement;\n          this.gradientManager.markUsed(displayable);\n          this.gradientManager.addWithoutUpdate(svgElement, displayable);\n          this.shadowManager.markUsed(displayable);\n          this.shadowManager.addWithoutUpdate(svgElement, displayable);\n          this.clipPathManager.markUsed(displayable);\n        }\n      }\n    }\n\n    this.gradientManager.removeUnused();\n    this.clipPathManager.removeUnused();\n    this.shadowManager.removeUnused();\n    this._visibleList = newVisibleList;\n  },\n  _getDefs: function (isForceCreating) {\n    var svgRoot = this._svgRoot;\n\n    var defs = this._svgRoot.getElementsByTagName('defs');\n\n    if (defs.length === 0) {\n      // Not exist\n      if (isForceCreating) {\n        var defs = svgRoot.insertBefore(createElement('defs'), // Create new tag\n        svgRoot.firstChild // Insert in the front of svg\n        );\n\n        if (!defs.contains) {\n          // IE doesn't support contains method\n          defs.contains = function (el) {\n            var children = defs.children;\n\n            if (!children) {\n              return false;\n            }\n\n            for (var i = children.length - 1; i >= 0; --i) {\n              if (children[i] === el) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n        }\n\n        return defs;\n      } else {\n        return null;\n      }\n    } else {\n      return defs[0];\n    }\n  },\n  resize: function (width, height) {\n    var viewport = this._viewport; // FIXME Why ?\n\n    viewport.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    viewport.style.display = '';\n\n    if (this._width !== width || this._height !== height) {\n      this._width = width;\n      this._height = height;\n      var viewportStyle = viewport.style;\n      viewportStyle.width = width + 'px';\n      viewportStyle.height = height + 'px';\n      var svgRoot = this._svgRoot; // Set width by 'svgRoot.width = width' is invalid\n\n      svgRoot.setAttribute('width', width);\n      svgRoot.setAttribute('height', height);\n    }\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  dispose: function () {\n    this.root.innerHTML = '';\n    this._svgRoot = this._viewport = this.storage = null;\n  },\n  clear: function () {\n    if (this._viewport) {\n      this.root.removeChild(this._viewport);\n    }\n  },\n  pathToDataUrl: function () {\n    this.refresh();\n    var html = this._svgRoot.outerHTML;\n    return 'data:image/svg+xml;charset=UTF-8,' + html;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    zrLog('In SVG mode painter not support method \"' + method + '\"');\n  };\n} // Unsuppoted methods\n\n\nutil.each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n  SVGPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = SVGPainter;\nmodule.exports = _default;"],"sourceRoot":""}